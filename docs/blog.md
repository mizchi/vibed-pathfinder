# RooCode にリファクタさせるオーケストレーターのプロンプト

Deno + Claude4 + RooCode。Claude 4 が進化しているので、それに合わせて Roo のプロンプトを書き直した。

AI へのお題はダイクストラによる経路探索の実装です。

## 効いたこと

- ハイラムの法則と単一責任原則に言及しながらリファクタさせる
  - https://ssaits.jp/promapedia/glossary/hyrums-law.html
- eslint の warn でかなり積極的なルールを採用して、それを根拠にリファクタリングさせる
  - 単体のファイルだけで実装できるように
  - 通常のテストではログが邪魔になるので通所の CI では `eslint --quiet` とする
- モデル自体の性能向上
  - デッドコードの削除、claude 3.x は無理だったが、 claude 4 と lint のおかげでやっとワークする

## RooCode のカスタマイズ

Roo Orchestrator がすごい。タスク分析、サブタスク分割、サブタスク要約だけ収集、でかなりコストが浮くようになった。

タスク設計の Orchestrator へのプロンプトを厚めに書いて、システムプロンプト自体は小さくした。

もはや Roo Code しか使ってないので特化プロンプトを用意。

- `.roo/rules/rules.md`: システムプロンプト
- `.roo/rules-orchestrator/workflows.md` カスタムワークフローを定義

## オーケストレーター用のプロンプトで、ワークフローを指示

開発フローを自前でいくつか定義して、それを使うように指示した。

1. 新機能追加ワークフロー
2. 単一ファイルリファクタリングワークフロー
3. ライブラリ API リファクタリングワークフロー
4. 公開 API の設計改善に焦点を当てたプロセス：

## 微妙な点

カットオフ時期のせいか neverthrow の学習量が増えて使えるようになったが、早期リターンできないせいでネストが深くなる。

テストコードの分岐で Unreachable な分岐を無限に作ってしまう。

```ts
Deno.test("...", async () => {
  if (result.isOk()) {
    assert(...)
  } else {
    ここに
  }
});
```

あとなんかやたら旧 API の互換性を取ろうとする。これはハイラムの法則に言及した自分が悪いのだが、それにしても固執する。旧 API を捨てろというと、やっと捨てる。
